\documentclass[12pt]{article}
\newcommand\tab[1][1cm]{\hspace*{#1}}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{color}
\pagenumbering{gobble}
\usepackage{changepage}

\usepackage{makecell}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\hypersetup{
	colorlinks,
	citecolor=black,
	filecolor=black,
	linkcolor=black,
	urlcolor=black
}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\begin{document}
	

\begin{titlepage}
	
\author{Eric Pereira}
\date{December 4\textsuperscript{th}, 2018}
\title{Homework 12-13}

\maketitle

\end{titlepage}

\tableofcontents

\newpage \pagenumbering{arabic}

\section*{12.6.1}
\addcontentsline{toc}{section}{\protect\numberline{}12.6.1}%

\subsection*{1. Given the binary floating-point value 1101.01101, how can it be expressed as a sum of decimal fractions?}
\addcontentsline{toc}{subsection}{\protect\numberline{}1. Given the binary floating-point value 1101.01101, how can it be expressed as a sum of decimal fractions?}%
Lets break this up into two parts, the part before the decimal and the part after the decimal. \\ \\
Before the decimal: 1101 \\ 
$1101 = 2^3 + 2^2 + 2^0 = 8 + 4 + 1 = 13$ \\ \\
After the decimal: 01101
$01101 = \frac{1}{4} + \frac{1}{8} + \frac{1}{32} = \frac{13}{32}$ or $0.40625$ \\ \\
Answer: When we put the two parts together we get $13\frac{13}{32}$ or $13.40625$
\subsection*{3. Given the binary value 11011.01011, what is its normalized value?}
\addcontentsline{toc}{subsection}{\protect\numberline{}3. Given the binary value 11011.01011, what is its normalized value?}%

in order to normalize the number by shifting it until there is a single 1 on the left side of the binary point. \\ \\
ex: 1.101101011 \\ \\ 
After this your exponent it based on how many position moved. Due to 4 movements left the normalized number is $2^4$ \\ \\
Answer: $1.101101011x2^4$
\subsection*{5. What are the two types of NaNs?}
\addcontentsline{toc}{subsection}{\protect\numberline{}5. What are the two types of NaNs?}%

The two types of NaN's are the quiet NaN and the signaling NaN.
\subsection*{6. What is the largest data type permitted by the FLD instruction, and how many bits does it contain?}
\addcontentsline{toc}{subsection}{\protect\numberline{}6. What is the largest data type permitted by the FLD instruction, and how many bits does it contain?}%

The largest data type permitted by the FLD instruction is REAL10, which contains 80 bits, or 10 bytes. 
\subsection*{7. How is the FSTP instruction different from FST?}
\addcontentsline{toc}{subsection}{\protect\numberline{}7. How is the FSTP instruction different from FST?}%

 FST will copy a floating-point operand from the top of the FPU stack, FSTP will copy and pop.
\subsection*{10. How is the FISUB instruction different from FSUB?}
\addcontentsline{toc}{subsection}{\protect\numberline{}10. How is the FISUB instruction different from FSUB?}%

FSUB will subtract with pop, so it pops that stack after performing subtraction. FISUB instruction converts the source operand to a floating point format before subtracting. 
\subsection*{13. Which field in the FPU control word lets you change the processor’s rounding mode?}
\addcontentsline{toc}{subsection}{\protect\numberline{}13. Which field in the FPU control word lets you change the processor’s rounding mode?}%
The RC field


\section*{12.6.2}
\addcontentsline{toc}{section}{\protect\numberline{}12.6.2}%
\subsection*{10. Write instructions that implement the following C++ code: \\
\texttt{int B = 7; \\
double N = 7.1; \\
double P = sqrt(N) + B;}}
\addcontentsline{toc}{subsection}{\protect\numberline{}10. Write instructions that implement the following C++ code:}%
Answer: \\
\texttt{.data \\
	B dword 7 \\
	N real8 7.1 \\
	P real8 ? \\
	\\
	.code \\
	main proc \\
	fld N \\
	fsqrt  \\
	fild B \\
	fadd \\
	fstp P \\
	INVOKE ExitProcess,0 \\
	main ENDP}

\section*{13.6}
\addcontentsline{toc}{section}{\protect\numberline{}13.6}%
\subsection*{1. When a procedure written in assembly language is called by a high-level language program, must the calling program and the procedure use the same memory model?}
\addcontentsline{toc}{subsection}{\protect\numberline{}1. When a procedure written in assembly language is called by a high-level language program, must the calling program and the procedure use the same memory model?}%
Yes the memory model determines if the call made is near or far.
\subsection*{3.  Does a language’s calling convention include the preserving of certain registers by procedures?}
\addcontentsline{toc}{subsection}{\protect\numberline{}3.  Does a language’s calling convention include the preserving of certain registers by procedures?}%
Yes, languages specify certain registers are preserved. 
\subsection*{6. (Yes/No): Can variables be defined with both the DW and the DUP operator in inline assembly code?}
\addcontentsline{toc}{subsection}{\protect\numberline{}6. (Yes/No): Can variables be defined with both the DW and the DUP operator in inline assembly code?}%
Yes
\subsection*{8.  Rather than using the OFFSET operator, is there another way to move a variable’s offset into an index register?}
\addcontentsline{toc}{subsection}{\protect\numberline{}8.  Rather than using the OFFSET operator, is there another way to move a variable’s offset into an index register?}%
Yes, you can use LEA instead. 
\subsection*{11. What is a valid assembly language PROTO declaration for the standard C printf( ) function?}
\addcontentsline{toc}{subsection}{\protect\numberline{}11. What is a valid assembly language PROTO declaration for the standard C printf( ) function?}%
\texttt{printf PROTO C, pString:PTR BYTE, args:VARARG}
\subsection*{13. What is the purpose of the “C” specifier in the extern declaration in procedures called from C++?}
\addcontentsline{toc}{subsection}{\protect\numberline{}13. What is the purpose of the “C” specifier in the extern declaration in procedures called from C++?}%
The 'C' specifier allows for C++ functions to be called from assembly language code. 

\end{document}

